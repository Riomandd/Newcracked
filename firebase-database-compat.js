! function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? t(require("@firebase/app-compat"), require("@firebase/app")) : "function" == typeof define && define.amd ? define(["@firebase/app-compat", "@firebase/app"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).firebase, e.firebase.INTERNAL.modularAPIs)
}(this, function(wo, Co) {
        "use strict";
        try {
            !(function() {
                    function e(e) {
                        return e && "object" == typeof e && "default" in e ? e : {
                            default: e
                        }
                    }
                    var n, t = e(wo);

                    function r(t) {
                        const n = [];
                        let r = 0;
                        for (let i = 0; i < t.length; i++) {
                            let e = t.charCodeAt(i);
                            e < 128 ? n[r++] = e : (e < 2048 ? n[r++] = e >> 6 | 192 : (55296 == (64512 & e) && i + 1 < t.length && 56320 == (64512 & t.charCodeAt(i + 1)) ? (e = 65536 + ((1023 & e) << 10) + (1023 & t.charCodeAt(++i)), n[r++] = e >> 18 | 240, n[r++] = e >> 12 & 63 | 128) : n[r++] = e >> 12 | 224, n[r++] = e >> 6 & 63 | 128), n[r++] = 63 & e | 128)
                        }
                        return n
                    }
                    const i = {
                            NODE_CLIENT: !1,
                            NODE_ADMIN: !1,
                            SDK_VERSION: "${JSCORE_VERSION}"
                        },
                        p = function(e, t) {
                            if (!e) throw c(t)
                        },
                        c = function(e) {
                            return new Error("Firebase Database (" + i.SDK_VERSION + ") INTERNAL ASSERT FAILED: " + e)
                        },
                        s = {
                            byteToCharMap_: null,
                            charToByteMap_: null,
                            byteToCharMapWebSafe_: null,
                            charToByteMapWebSafe_: null,
                            ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
                            get ENCODED_VALS() {
                                return this.ENCODED_VALS_BASE + "+/="
                            },
                            get ENCODED_VALS_WEBSAFE() {
                                return this.ENCODED_VALS_BASE + "-_."
                            },
                            HAS_NATIVE_SUPPORT: "function" == typeof atob,
                            encodeByteArray(n, e) {
                                if (!Array.isArray(n)) throw Error("encodeByteArray takes an array as a parameter");
                                this.init_();
                                var r = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
                                const i = [];
                                for (let c = 0; c < n.length; c += 3) {
                                    var s = n[c],
                                        o = c + 1 < n.length,
                                        a = o ? n[c + 1] : 0,
                                        l = c + 2 < n.length,
                                        h = l ? n[c + 2] : 0;
                                    let e = (15 & a) << 2 | h >> 6,
                                        t = 63 & h;
                                    l || (t = 64, o || (e = 64)), i.push(r[s >> 2], r[(3 & s) << 4 | a >> 4], r[e], r[t])
                                }
                                return i.join("")
                            },
                            encodeString(e, t) {
                                return this.HAS_NATIVE_SUPPORT && !t ? btoa(e) : this.encodeByteArray(r(e), t)
                            },
                            decodeString(e, t) {
                                return this.HAS_NATIVE_SUPPORT && !t ? atob(e) : function(e) {
                                    const t = [];
                                    let n = 0,
                                        r = 0;
                                    for (; n < e.length;) {
                                        var i, s, o = e[n++];
                                        o < 128 ? t[r++] = String.fromCharCode(o) : 191 < o && o < 224 ? (i = e[n++], t[r++] = String.fromCharCode((31 & o) << 6 | 63 & i)) : 239 < o && o < 365 ? (s = ((7 & o) << 18 | (63 & e[n++]) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) - 65536, t[r++] = String.fromCharCode(55296 + (s >> 10)), t[r++] = String.fromCharCode(56320 + (1023 & s))) : (i = e[n++], s = e[n++], t[r++] = String.fromCharCode((15 & o) << 12 | (63 & i) << 6 | 63 & s))
                                    }
                                    return t.join("")
                                }(this.decodeStringToByteArray(e, t))
                            },
                            decodeStringToByteArray(e, t) {
                                this.init_();
                                var n = t ? this.charToByteMapWebSafe_ : this.charToByteMap_;
                                const r = [];
                                for (let l = 0; l < e.length;) {
                                    var i = n[e.charAt(l++)],
                                        s = l < e.length ? n[e.charAt(l)] : 0;
                                    ++l;
                                    var o = l < e.length ? n[e.charAt(l)] : 64;
                                    ++l;
                                    var a = l < e.length ? n[e.charAt(l)] : 64;
                                    if (++l, null == i || null == s || null == o || null == a) throw new h;
                                    r.push(i << 2 | s >> 4), 64 !== o && (r.push(s << 4 & 240 | o >> 2), 64 !== a && r.push(o << 6 & 192 | a))
                                }
                                return r
                            },
                            init_() {
                                if (!this.byteToCharMap_) {
                                    this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
                                    for (let e = 0; e < this.ENCODED_VALS.length; e++) this.byteToCharMap_[e] = this.ENCODED_VALS.charAt(e), this.charToByteMap_[this.byteToCharMap_[e]] = e, this.byteToCharMapWebSafe_[e] = this.ENCODED_VALS_WEBSAFE.charAt(e), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]] = e, e >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)] = e, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)] = e)
                                }
                            }
                        };
                    class h extends Error {
                        constructor() {
                            super(...arguments), this.name = "DecodeBase64StringError"
                        }
                    }

                    function o(e) {
                        var t = r(e);
                        return s.encodeByteArray(t, !0)
                    }
                    const a = function(e) {
                            return o(e).replace(/\./g, "")
                        },
                        l = function(e) {
                            try {
                                return s.decodeString(e, !0)
                            } catch (e) {
                                console.error("base64Decode failed: ", e)
                            }
                            return null
                        };

                    function u(e) {
                        return function e(t, n) {
                            if (!(n instanceof Object)) return n;
                            switch (n.constructor) {
                                case Date:
                                    const r = n;
                                    return new Date(r.getTime());
                                case Object:
                                    void 0 === t && (t = {});
                                    break;
                                case Array:
                                    t = [];
                                    break;
                                default:
                                    return n
                            }
                            for (const i in n) n.hasOwnProperty(i) && d(i) && (t[i] = e(t[i], n[i]));
                            return t
                        }(void 0, e)
                    }

                    function d(e) {
                        return "__proto__" !== e
                    }
                    class _ {
                        constructor() {
                            this.reject = () => {}, this.resolve = () => {}, this.promise = new Promise((e, t) => {
                                this.resolve = e, this.reject = t
                            })
                        }
                        wrapCallback(n) {
                            return (e, t) => {
                                e ? this.reject(e) : this.resolve(t), "function" == typeof n && (this.promise.catch(() => {}), 1 === n.length ? n(e) : n(e, t))
                            }
                        }
                    }

                    function f() {
                        return "undefined" != typeof window && (window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test("undefined" != typeof navigator && "string" == typeof navigator.userAgent ? navigator.userAgent : "")
                    }

                    function g() {
                        return !0 === i.NODE_ADMIN
                    }

                    function m(e) {
                        return JSON.parse(e)
                    }

                    function v(e) {
                        return JSON.stringify(e)
                    }

                    function y(e) {
                        let t = {},
                            n = {},
                            r = {},
                            i = "";
                        try {
                            var s = e.split(".");
                            t = m(l(s[0]) || ""), n = m(l(s[1]) || ""), i = s[2], r = n.d || {}, delete n.d
                        } catch (e) {}
                        return {
                            header: t,
                            claims: n,
                            data: r,
                            signature: i
                        }
                    }

                    function w(e, t) {
                        return Object.prototype.hasOwnProperty.call(e, t)
                    }

                    function C(e, t) {
                        if (Object.prototype.hasOwnProperty.call(e, t)) return e[t]
                    }

                    function b(e) {
                        for (const t in e)
                            if (Object.prototype.hasOwnProperty.call(e, t)) return !1;
                        return !0
                    }

                    function I(e, t, n) {
                        const r = {};
                        for (const i in e) Object.prototype.hasOwnProperty.call(e, i) && (r[i] = t.call(n, e[i], i, e));
                        return r
                    }
                    class T {
                        constructor() {
                            this.chain_ = [], this.buf_ = [], this.W_ = [], this.pad_ = [], this.inbuf_ = 0, this.total_ = 0, this.blockSize = 64, this.pad_[0] = 128;
                            for (let e = 1; e < this.blockSize; ++e) this.pad_[e] = 0;
                            this.reset()
                        }
                        reset() {
                            this.chain_[0] = 1732584193, this.chain_[1] = 4023233417, this.chain_[2] = 2562383102, this.chain_[3] = 271733878, this.chain_[4] = 3285377520, this.inbuf_ = 0, this.total_ = 0
                        }
                        compress_(n, r) {
                            r = r || 0;
                            const i = this.W_;
                            if ("string" == typeof n)
                                for (let e = 0; e < 16; e++) i[e] = n.charCodeAt(r) << 24 | n.charCodeAt(r + 1) << 16 | n.charCodeAt(r + 2) << 8 | n.charCodeAt(r + 3), r += 4;
                            else
                                for (let t = 0; t < 16; t++) i[t] = n[r] << 24 | n[r + 1] << 16 | n[r + 2] << 8 | n[r + 3], r += 4;
                            for (let d = 16; d < 80; d++) {
                                var e = i[d - 3] ^ i[d - 8] ^ i[d - 14] ^ i[d - 16];
                                i[d] = 4294967295 & (e << 1 | e >>> 31)
                            }
                            let t = this.chain_[0],
                                s = this.chain_[1],
                                o = this.chain_[2],
                                a = this.chain_[3],
                                l = this.chain_[4],
                                h, c;
                            for (let _ = 0; _ < 80; _++) {
                                c = _ < 40 ? _ < 20 ? (h = a ^ s & (o ^ a), 1518500249) : (h = s ^ o ^ a, 1859775393) : _ < 60 ? (h = s & o | a & (s | o), 2400959708) : (h = s ^ o ^ a, 3395469782);
                                var u = (t << 5 | t >>> 27) + h + l + c + i[_] & 4294967295;
                                l = a, a = o, o = 4294967295 & (s << 30 | s >>> 2), s = t, t = u
                            }
                            this.chain_[0] = this.chain_[0] + t & 4294967295, this.chain_[1] = this.chain_[1] + s & 4294967295, this.chain_[2] = this.chain_[2] + o & 4294967295, this.chain_[3] = this.chain_[3] + a & 4294967295, this.chain_[4] = this.chain_[4] + l & 4294967295
                        }
                        update(n, r) {
                            if (null != n) {
                                var i = (r = void 0 === r ? n.length : r) - this.blockSize;
                                let e = 0;
                                const s = this.buf_;
                                let t = this.inbuf_;
                                for (; e < r;) {
                                    if (0 === t)
                                        for (; e <= i;) this.compress_(n, e), e += this.blockSize;
                                    if ("string" == typeof n) {
                                        for (; e < r;)
                                            if (s[t] = n.charCodeAt(e), ++t, ++e, t === this.blockSize) {
                                                this.compress_(s), t = 0;
                                                break
                                            }
                                    } else
                                        for (; e < r;)
                                            if (s[t] = n[e], ++t, ++e, t === this.blockSize) {
                                                this.compress_(s), t = 0;
                                                break
                                            }
                                }
                                this.inbuf_ = t, this.total_ += r
                            }
                        }
                        digest() {
                            const t = [];
                            let e = 8 * this.total_;
                            this.inbuf_ < 56 ? this.update(this.pad_, 56 - this.inbuf_) : this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
                            for (let r = this.blockSize - 1; 56 <= r; r--) this.buf_[r] = 255 & e, e /= 256;
                            this.compress_(this.buf_);
                            let n = 0;
                            for (let i = 0; i < 5; i++)
                                for (let e = 24; 0 <= e; e -= 8) t[n] = this.chain_[i] >> e & 255, ++n;
                            return t
                        }
                    }

                    function E(e, t, n, r) {
                        let i;
                        if (r < t ? i = "at least " + t : n < r && (i = 0 === n ? "none" : "no more than " + n), i) {
                            var s = e + " failed: Was called with " + r + (1 === r ? " argument." : " arguments.") + " Expects " + i + ".";
                            throw new Error(s)
                        }
                    }

                    function S(e, t) {
                        return `${e} failed: ${t} argument `
                    }

                    function k(e, t, n, r) {
                        if ((!r || n) && "function" != typeof n) throw new Error(S(e, t) + "must be a valid function.")
                    }

                    function N(e, t, n, r) {
                        if ((!r || n) && ("object" != typeof n || null === n)) throw new Error(S(e, t) + "must be a valid context object.")
                    }
                    const P = function(e) {
                        let t = 0;
                        for (let r = 0; r < e.length; r++) {
                            var n = e.charCodeAt(r);
                            n < 128 ? t++ : n < 2048 ? t += 2 : 55296 <= n && n <= 56319 ? (t += 4, r++) : t += 3
                        }
                        return t
                    };

                    function R(e) {
                        return e && e._delegate ? e._delegate : e
                    }
                    class x {
                        constructor(e, t, n) {
                            this.name = e, this.instanceFactory = t, this.type = n, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null
                        }
                        setInstantiationMode(e) {
                            return this.instantiationMode = e, this
                        }
                        setMultipleInstances(e) {
                            return this.multipleInstances = e, this
                        }
                        setServiceProps(e) {
                            return this.serviceProps = e, this
                        }
                        setInstanceCreatedCallback(e) {
                            return this.onInstanceCreated = e, this
                        }
                    }
                    const D = "[DEFAULT]";
                    class A {
                        constructor(e, t) {
                            this.name = e, this.container = t, this.component = null, this.instances = new Map, this.instancesDeferred = new Map, this.instancesOptions = new Map, this.onInitCallbacks = new Map
                        }
                        get(e) {
                            var t = this.normalizeInstanceIdentifier(e);
                            if (!this.instancesDeferred.has(t)) {
                                const r = new _;
                                if (this.instancesDeferred.set(t, r), this.isInitialized(t) || this.shouldAutoInitialize()) try {
                                    var n = this.getOrInitializeService({
                                        instanceIdentifier: t
                                    });
                                    n && r.resolve(n)
                                } catch (e) {}
                            }
                            return this.instancesDeferred.get(t).promise
                        }
                        getImmediate(e) {
                            var t = this.normalizeInstanceIdentifier(null == e ? void 0 : e.identifier),
                                n = null !== (n = null == e ? void 0 : e.optional) && void 0 !== n && n;
                            if (!this.isInitialized(t) && !this.shouldAutoInitialize()) {
                                if (n) return null;
                                throw Error(`Service ${this.name} is not available`)
                            }
                            try {
                                return this.getOrInitializeService({
                                    instanceIdentifier: t
                                })
                            } catch (e) {
                                if (n) return null;
                                throw e
                            }
                        }
                        getComponent() {
                            return this.component
                        }
                        setComponent(e) {
                            if (e.name !== this.name) throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
                            if (this.component) throw Error(`Component for ${this.name} has already been provided`);
                            if (this.component = e, this.shouldAutoInitialize()) {
                                if ("EAGER" === e.instantiationMode) try {
                                    this.getOrInitializeService({
                                        instanceIdentifier: D
                                    })
                                } catch (e) {}
                                for (var [t, n] of this.instancesDeferred.entries()) {
                                    t = this.normalizeInstanceIdentifier(t);
                                    try {
                                        var r = this.getOrInitializeService({
                                            instanceIdentifier: t
                                        });
                                        n.resolve(r)
                                    } catch (e) {}
                                }
                            }
                        }
                        clearInstance(e = D) {
                            this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e)
                        }
                        async delete() {
                            const e = Array.from(this.instances.values());
                            await Promise.all([...e.filter(e => "INTERNAL" in e).map(e => e.INTERNAL.delete()), ...e.filter(e => "_delete" in e).map(e => e._delete())])
                        }
                        isComponentSet() {
                            return null != this.component
                        }
                        isInitialized(e = D) {
                            return this.instances.has(e)
                        }
                        getOptions(e = D) {
                            return this.instancesOptions.get(e) || {}
                        }
                        initialize(e = {}) {
                            var {
                                options: t = {}
                            } = e, n = this.normalizeInstanceIdentifier(e.instanceIdentifier);
                            if (this.isInitialized(n)) throw Error(`${this.name}(${n}) has already been initialized`);
                            if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`);
                            var r, i, s = this.getOrInitializeService({
                                instanceIdentifier: n,
                                options: t
                            });
                            for ([r, i] of this.instancesDeferred.entries()) n === this.normalizeInstanceIdentifier(r) && i.resolve(s);
                            return s
                        }
                        onInit(e, t) {
                            var n = this.normalizeInstanceIdentifier(t);
                            const r = null !== (i = this.onInitCallbacks.get(n)) && void 0 !== i ? i : new Set;
                            r.add(e), this.onInitCallbacks.set(n, r);
                            var i = this.instances.get(n);
                            return i && e(i, n), () => {
                                r.delete(e)
                            }
                        }
                        invokeOnInitCallbacks(e, t) {
                            var n = this.onInitCallbacks.get(t);
                            if (n)
                                for (const r of n) try {
                                    r(e, t)
                                } catch (e) {}
                        }
                        getOrInitializeService({
                            instanceIdentifier: e,
                            options: t = {}
                        }) {
                            let n = this.instances.get(e);
                            if (!n && this.component && (n = this.component.instanceFactory(this.container, {
                                    instanceIdentifier: (r = e) === D ? void 0 : r,
                                    options: t
                                }), this.instances.set(e, n), this.instancesOptions.set(e, t), this.invokeOnInitCallbacks(n, e), this.component.onInstanceCreated)) try {
                                this.component.onInstanceCreated(this.container, e, n)
                            } catch (e) {}
                            var r;
                            return n || null
                        }
                        normalizeInstanceIdentifier(e = D) {
                            return !this.component || this.component.multipleInstances ? e : D
                        }
                        shouldAutoInitialize() {
                            return !!this.component && "EXPLICIT" !== this.component.instantiationMode
                        }
                    }
                    class O {
                        constructor(e) {
                            this.name = e, this.providers = new Map
                        }
                        addComponent(e) {
                            const t = this.getProvider(e.name);
                            if (t.isComponentSet()) throw new Error(`Component ${e.name} has already been registered with ${this.name}`);
                            t.setComponent(e)
                        }
                        addOrOverwriteComponent(e) {
                            const t = this.getProvider(e.name);
                            t.isComponentSet() && this.providers.delete(e.name), this.addComponent(e)
                        }
                        getProvider(e) {
                            if (this.providers.has(e)) return this.providers.get(e);
                            var t = new A(e, this);
                            return this.providers.set(e, t), t
                        }
                        getProviders() {
                            return Array.from(this.providers.values())
                        }
                    }($ = n = n || {})[$.DEBUG = 0] = "DEBUG", $[$.VERBOSE = 1] = "VERBOSE", $[$.INFO = 2] = "INFO", $[$.WARN = 3] = "WARN", $[$.ERROR = 4] = "ERROR", $[$.SILENT = 5] = "SILENT";
                    const L = {
                            debug: n.DEBUG,
                            verbose: n.VERBOSE,
                            info: n.INFO,
                            warn: n.WARN,
                            error: n.ERROR,
                            silent: n.SILENT
                        },
                        M = n.INFO,
                        F = {
                            [n.DEBUG]: "log",
                            [n.VERBOSE]: "log",
                            [n.INFO]: "info",
                            [n.WARN]: "warn",
                            [n.ERROR]: "error"
                        },
                        q = (e, t, ...n) => {
                            if (!(t < e.logLevel)) {
                                var r = (new Date).toISOString(),
                                    i = F[t];
                                if (!i) throw new Error(`Attempted to log a message with an invalid logType (value: ${t})`);
                                console[i](`[${r}]  ${e.name}:`, ...n)
                            }
                        };
                    class W {
                        constructor(e) {
                            this.name = e, this._logLevel = M, this._logHandler = q, this._userLogHandler = null
                        }
                        get logLevel() {
                            return this._logLevel
                        }
                        set logLevel(e) {
                            if (!(e in n)) throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
                            this._logLevel = e
                        }
                        setLogLevel(e) {
                            this._logLevel = "string" == typeof e ? L[e] : e
                        }
                        get logHandler() {
                            return this._logHandler
                        }
                        set logHandler(e) {
                            if ("function" != typeof e) throw new TypeError("Value assigned to `logHandler` must be a function");
                            this._logHandler = e
                        }
                        get userLogHandler() {
                            return this._userLogHandler
                        }
                        set userLogHandler(e) {
                            this._userLogHandler = e
                        }
                        debug(...e) {
                            this._userLogHandler && this._userLogHandler(this, n.DEBUG, ...e), this._logHandler(this, n.DEBUG, ...e)
                        }
                        log(...e) {
                            this._userLogHandler && this._userLogHandler(this, n.VERBOSE, ...e), this._logHandler(this, n.VERBOSE, ...e)
                        }
                        info(...e) {
                            this._userLogHandler && this._userLogHandler(this, n.INFO, ...e), this._logHandler(this, n.INFO, ...e)
                        }
                        warn(...e) {
                            this._userLogHandler && this._userLogHandler(this, n.WARN, ...e), this._logHandler(this, n.WARN, ...e)
                        }
                        error(...e) {
                            this._userLogHandler && this._userLogHandler(this, n.ERROR, ...e), this._logHandler(this, n.ERROR, ...e)
                        }
                    }
                    const U = "@firebase/database";
                    let B = "";

                    function j(e) {
                        B = e
                    }
                    class V {
                        constructor(e) {
                            this.domStorage_ = e, this.prefix_ = "firebase:"
                        }
                        set(e, t) {
                            null == t ? this.domStorage_.removeItem(this.prefixedName_(e)) : this.domStorage_.setItem(this.prefixedName_(e), v(t))
                        }
                        get(e) {
                            var t = this.domStorage_.getItem(this.prefixedName_(e));
                            return null == t ? null : m(t)
                        }
                        remove(e) {
                            this.domStorage_.removeItem(this.prefixedName_(e))
                        }
                        prefixedName_(e) {
                            return this.prefix_ + e
                        }
                        toString() {
                            return this.domStorage_.toString()
                        }
                    }
                    class z {
                        constructor() {
                            this.cache_ = {}, this.isInMemoryStorage = !0
                        }
                        set(e, t) {
                            null == t ? delete this.cache_[e] : this.cache_[e] = t
                        }
                        get(e) {
                            return w(this.cache_, e) ? this.cache_[e] : null
                        }
                        remove(e) {
                            delete this.cache_[e]
                        }
                    }

                    function H(e) {
                        try {
                            if ("undefined" != typeof window && void 0 !== window[e]) {
                                const t = window[e];
                                return t.setItem("firebase:sentinel", "cache"), t.removeItem("firebase:sentinel"), new V(t)
                            }
                        } catch (e) {}
                        return new z
                    }
                    var Q, Y, K, $, G, J, X;

                    function Z(e) {
                        var t = function(t) {
                            const n = [];
                            let r = 0;
                            for (let o = 0; o < t.length; o++) {
                                let e = t.charCodeAt(o);
                                var i, s;
                                55296 <= e && e <= 56319 && (i = e - 55296, o++, p(o < t.length, "Surrogate pair missing trail surrogate."), s = t.charCodeAt(o) - 56320, e = 65536 + (i << 10) + s), e < 128 ? n[r++] = e : (e < 2048 ? n[r++] = e >> 6 | 192 : (e < 65536 ? n[r++] = e >> 12 | 224 : (n[r++] = e >> 18 | 240, n[r++] = e >> 12 & 63 | 128), n[r++] = e >> 6 & 63 | 128), n[r++] = 63 & e | 128)
                            }
                            return n
                        }(e);
                        const n = new T;
                        return n.update(t), t = n.digest(), s.encodeByteArray(t)
                    }
                    const ee = H("localStorage"),
                        te = H("sessionStorage"),
                        ne = new W("@firebase/database"),
                        re = function() {
                            let e = 1;
                            return function() {
                                return e++
                            }
                        }(),
                        ie = function(...e) {
                            let t = "";
                            for (let r = 0; r < e.length; r++) {
                                var n = e[r];
                                Array.isArray(n) || n && "object" == typeof n && "number" == typeof n.length ? t += ie.apply(null, n) : t += "object" == typeof n ? v(n) : n, t += " "
                            }
                            return t
                        };
                    let se = null,
                        oe = !0;

                    function ae(t) {
                        return function(...e) {
                            pe(t, ...e)
                        }
                    }

                    function le(...e) {
                        var t = "FIREBASE INTERNAL ERROR: " + ie(...e);
                        ne.error(t)
                    }

                    function he(e, t) {
                        return e === t ? 0 : e < t ? -1 : 1
                    }

                    function ce(e, t) {
                        if (t && e in t) return t[e];
                        throw new Error("Missing required key (" + e + ") in object: " + v(t))
                    }

                    function ue(e) {
                        if ("object" != typeof e || null === e) return v(e);
                        const t = [];
                        for (const r in e) t.push(r);
                        t.sort();
                        let n = "{";
                        for (let i = 0; i < t.length; i++) 0 !== i && (n += ","), n += v(t[i]), n += ":", n += ue(e[t[i]]);
                        return n += "}", n
                    }

                    function de(e, t) {
                        var n = e.length;
                        if (n <= t) return [e];
                        const r = [];
                        for (let i = 0; i < n; i += t) i + t > n ? r.push(e.substring(i, n)) : r.push(e.substring(i, i + t));
                        return r
                    }
                    const _e = function(e, t) {
                            p(!t || !0 === e || !1 === e, "Can't turn on custom loggers persistently."), !0 === e ? (ne.logLevel = n.VERBOSE, se = ne.log.bind(ne), t && te.set("logging_enabled", !0)) : "function" == typeof e ? se = e : (se = null, te.remove("logging_enabled"))
                        },
                        pe = function(...e) {
                            var t;
                            !0 === oe && (oe = !1, null === se && !0 === te.get("logging_enabled") && _e(!0)), se && (t = ie.apply(null, e), se(t))
                        },
                        fe = function(...e) {
                            var t = `FIREBASE FATAL ERROR: ${ie(...e)}`;
                            throw ne.error(t), new Error(t)
                        },
                        ge = function(...e) {
                            var t = "FIREBASE WARNING: " + ie(...e);
                            ne.warn(t)
                        },
                        me = function() {
                            "undefined" != typeof window && window.location && window.location.protocol && -1 !== window.location.protocol.indexOf("https:") && ge("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().")
                        },
                        ve = function(e) {
                            return "number" == typeof e && (e != e || e === Number.POSITIVE_INFINITY || e === Number.NEGATIVE_INFINITY)
                        },
                        ye = "[MIN_NAME]",
                        we = "[MAX_NAME]",
                        Ce = function(e, t) {
                            if (e === t) return 0;
                            if (e === ye || t === we) return -1;
                            if (t === ye || e === we) return 1;
                            var n = Te(e),
                                r = Te(t);
                            return null !== n ? null !== r ? n - r == 0 ? e.length - t.length : n - r : -1 : null === r && e < t ? -1 : 1
                        };

                    function be(e, t) {
                        for (const n in e) e.hasOwnProperty(n) && t(n, e[n])
                    }

                    function Ie(e) {
                        p(!ve(e), "Invalid JSON number");
                        let t, n, r, i, s;
                        0 === e ? (n = 0, r = 0, t = 1 / e == -1 / 0 ? 1 : 0) : (t = e < 0, e = Math.abs(e), r = e >= Math.pow(2, -1022) ? (i = Math.min(Math.floor(Math.log(e) / Math.LN2), 1023), n = i + 1023, Math.round(e * Math.pow(2, 52 - i) - Math.pow(2, 52))) : (n = 0, Math.round(e / Math.pow(2, -1074))));
                        const o = [];
                        for (s = 52; s; --s) o.push(r % 2 ? 1 : 0), r = Math.floor(r / 2);
                        for (s = 11; s; --s) o.push(n % 2 ? 1 : 0), n = Math.floor(n / 2);
                        o.push(t ? 1 : 0), o.reverse();
                        const a = o.join("");
                        let l = "";
                        for (s = 0; s < 64; s += 8) {
                            let e = parseInt(a.substr(s, 8), 2).toString(16);
                            1 === e.length && (e = "0" + e), l += e
                        }
                        return l.toLowerCase()
                    }

                    function Te(e) {
                        if (Se.test(e)) {
                            var t = Number(e);
                            if (t >= ke && t <= Ne) return t
                        }
                        return null
                    }

                    function Ee(e, t) {
                        const n = setTimeout(e, t);
                        return "number" == typeof n && "undefined" != typeof Deno && Deno.unrefTimer ? Deno.unrefTimer(n) : "object" == typeof n && n.unref && n.unref(), n
                    }
                    const Se = new RegExp("^-?(0*)\\d{1,10}$"),
                        ke = -2147483648,
                        Ne = 2147483647,
                        Pe = function(e) {
                            try {
                                e()
                            } catch (t) {
                                setTimeout(() => {
                                    var e = t.stack || "";
                                    throw ge("Exception was thrown by user callback.", e), t
                                }, Math.floor(0))
                            }
                        };
                    class Re {
                        constructor(e, t) {
                            this.appName_ = e, this.appCheckProvider = t, this.appCheck = null == t ? void 0 : t.getImmediate({
                                optional: !0
                            }), this.appCheck || null != t && t.get().then(e => this.appCheck = e)
                        }
                        getToken(n) {
                            return this.appCheck ? this.appCheck.getToken(n) : new Promise((e, t) => {
                                setTimeout(() => {
                                    this.appCheck ? this.getToken(n).then(e, t) : e(null)
                                }, 0)
                            })
                        }
                        addTokenChangeListener(t) {
                            var e;
                            null !== (e = this.appCheckProvider) && void 0 !== e && e.get().then(e => e.addTokenListener(t))
                        }
                        notifyForInvalidToken() {
                            ge(`Provided AppCheck credentials for the app named "${this.appName_}" ` + "are invalid. This usually indicates your app was not initialized correctly.")
                        }
                    }
                    class xe {
                        constructor(e, t, n) {
                            this.appName_ = e, this.firebaseOptions_ = t, this.authProvider_ = n, this.auth_ = null, this.auth_ = n.getImmediate({
                                optional: !0
                            }), this.auth_ || n.onInit(e => this.auth_ = e)
                        }
                        getToken(n) {
                            return this.auth_ ? this.auth_.getToken(n).catch(e => e && "auth/token-not-initialized" === e.code ? (pe("Got auth/token-not-initialized error.  Treating as null token."), null) : Promise.reject(e)) : new Promise((e, t) => {
                                setTimeout(() => {
                                    this.auth_ ? this.getToken(n).then(e, t) : e(null)
                                }, 0)
                            })
                        }
                        addTokenChangeListener(t) {
                            this.auth_ ? this.auth_.addAuthTokenListener(t) : this.authProvider_.get().then(e => e.addAuthTokenListener(t))
                        }
                        removeTokenChangeListener(t) {
                            this.authProvider_.get().then(e => e.removeAuthTokenListener(t))
                        }
                        notifyForInvalidToken() {
                                let e = 'Provided authentication credentials for the app named "' + this.appName_ + '" are invalid. This usually indicates your app was not initialized correctly. ';
                                "credential" in this.firebaseOptions_ ? e += 'Make sure the "credential" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.' : "serviceAccount" in this.firebaseOptions_ ? e += 'Make sure the "serviceAccount" property provided to initializeApp() is authorized to access the

View all